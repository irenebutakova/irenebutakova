---
published: true
layout: post
title: The psychology of design patterns&#58; where problem and solution overlap.
date: 2018-09-13
---

Навеяно дискуссиями в группе...

*Саша.* Я тут кропотал над Декоратором, постигал Лекговеса, докапывался до сути Компоновщика, осмысливал
проблемы Синглтона, исследовал Посетителя, разбирался с Командой, осознавал Стратегию, медитировал со Строителем...

*Паша.* Уловили...

*Саша.* Проштудировал несколько книг, прослушал десятки видеоуроков, просмотрел сотни примеров...

*Паша.* И судя по количеству освоенного материала точку на теме ставить рано.

*Саша.* Просто я пытаюсь понять алгоритм решения проблемы, но обратил внимание, что иногда алгоритмы различных источников отличаются.

*Маша.* Потому что паттерн - это не образец кода, а название проблемы, и в зависимости от деталей алгоритм можно немножко модифицировать.

*Саша.* Меня это как-то с толку сбивает. Разве паттерн не должен быть более или менее однозначно переложен на код? Ведь тогда всем разработчикам понятно, о чем идет речь.

*Маша.* Речь идет все об одном - о разработке гибкого программного обеспечения и соблюдении принципов проектирования. Загвоздка в том, что ты кропотал, постигал, и медитировал в поисках наилучшего решения проблемы, но упустил ее суть.

*Саша.* Как-то не добавляет ясности.

*Маша.* Паттерны потому и называются паттерны. Одну проблему можно решить по-разному, но на основании определенного подхода к проектированию. Потому вполне реально оказаться в ситуации, когда разработчик Ваня понимает под Паттерном П не то же самое, что понимает разработчик Даня.

*Саша.* Совсем запутался.

*Маша.* По сути, паттерны показывают отношения и взаимодействия между классами и объектами. Изучая паттерны, ты видишь, как работают принципы проектирования. Понимаешь, какими способами можно решить задачу, и какие оттуда вытекают последствия. Куда пойдет наследование, а где использовать композицию. Зачем использовать принцип инверсии зависимостей. И наконец-то до тебя доходит, что паттерны - это не код, который можно просто
скопировать в приложение, и он будет работать. И ты из кодера превращаешься в программиста.

*Саша.* А что, есть еще превращения?

*Маша.* В разработчика, в инжерера.

*Саша.* Это как?

*Маша.* Разработчик - это программист с некоторым опытом, который понимает, что код нужно поддерживать, поэтому старается избегать нечитаемости. А инженер - это программист, относящийся к своей работе как к ремеслу, совершенствующий это ремесло, умеющий увидеть проблему и вникнуть в ее суть, оценить способы ее решения и выбрать подходящий trade-off.

*Петя.* Это ты разъяснила, что значит плохо, нормально, и хорошо?

*Маша.* Это я разъяснила заблуждения относительно паттернов проектирования.

*Саша.* Вот только до сих пор до меня одни паттерны не дошли, а между другими я вовсе не вижу разницы.

*Маша.* Читай, реализуй, усложняй, добавляй, исправляй.

*Саша.* А если я и распознаю паттерн и применяю его на практике, то код каким-то сложным получается, другой раз не уверен, уместен ли паттерн.

*Витя.* Известная болезнь. Потому лучше KISS, или не используй паттерн, если сомневаешься.

*Даша.* А помните, Пол говорил, что паттерны нужно чувствовать, понимать, где и в какой ситуации использовать тот или иной паттерн. А в ряде случаев так вообще отказаться от применения каких-либо паттернов.

*Саша.* Так что по большей части можно наверное и не использовать.

*Маша.* Еще как используй. В учебе. Иначе не освоишь. Для этого придумай проблему (например, домашнее задание), попытайся забавно ее решить, со всеми ненужными и неуместными паттернами и вытекающими оттуда последствиями. Тогда и почувствуешь принципы проектирования.

*Витя.* Используй, но только не паттерн Лихорадка.

*Саша.* Лихорадка?

*Витя.* Узнаешь про паттерн, когда начнешь использовать шаблоны проектирования для Hello World.

*Саша.* Кажется, понял. Но раз паттерны - все о принципах проектирования, зачем тогда Барри собеседовать нас не только по принципам проектирования, но и по паттернам?

*Маша.* Затем, что в паттернах раскрываются принципы проектирования. Описываются часто встречающиеся проблемы и принципы их решения. Воспринимай это как проверку понимания таких проблем, как дублирование кода, избыточность в иерархии классов, про и контра наследования и композиции, уместность абстрактного типа в качестве типа возвращаемого значения, понимание шаблонов распределения ответственности (low-coupling, high-cohesion), и т.д.

*Саша.* Допустим, я смогу описать проблему, изложенную паттерном. Технически. Но рассказать про ее решение будет неверно. Идеологически. Ведь сама сказала, что решение не может быть конкретным, потому что зависит от контекста.

*Петя.* Опиши проблему на абстрактном уровне и на свое усмотрение приведи в пример конкретную задачу, а потом расскажи про вариант/варианты решения с вытекающими преимуществами и недостатками.

*Саша.* Раньше я писал код и не переставал думать, что, должно быть, существует лучший способ решения задачи. Потом я проводил следующие несколько дней и ночей, придумывая решение, которым бы мог гордиться. Сейчас же на помощь приходит чужой опыт под названием шаблоны проектирования.

*Витя.* Дорога тебе из программиста через разработчика в инженеры.


> Все герои вымышлены, полное или частичное сходство является совпадением.
