---
published: true
layout: post
title: Be sure who creates your objects.
date: 2018-04-23
---
Навеяно дискуссиями в группе...

*Саша.* Знаете, я вот разбираюсь с удобным и безопасным созданием новых объектов в Порождающих шаблонах.
Могу только сказать, что до изучения Порождающие шаблоны были *просто* Порождающими шаблонами. А теперь, после изучения, Порождающие шаблоны стали Порождающими шаблонами.

*Петя.* И что же скрывается за этим *просто*?

*Саша.* А вот взять к примеру Абстрактную фабрику и Фабричный метод. По сути ведь вызов конструктора, порождающего другой объект, просто перемещается из одного класса в другой. И что же здесь за преимущество? Чем плохо по месту вызвать

```c#
SomeType1 st = new SomeType1();
```
Так нет, нужен дополнительный код, дополнительные классы...

*Маша.* Таким образом можно создать объект только того класса, конструктор которого вызываешь.

*Саша.* То есть тип моего объекта - исключительно SomeType1?

*Маша.* Именно. А если, скажем, у SomeType1 есть свойство, которое может отличать его от других SomeType1?

*Витя.* Так можно спроектировать SomeType2.

*Маша.* Можно, несомненно. Проектирование реализациями налицо. DIP-принцип не удружил.

*Даша.* А помните, Пол говорил, проектировать абстракциями, а не реализациями? Вполне уместно создать абстрактный класс SomeType, от которого будут наследоваться SomeType1 и SomeType2.

*Саша.* Понял, тогда можно вызвать
```c#
SomeType st1 = new SomeType1();
  или
SomeType st2 = new SomeType2();
```
*Петя.* Но остается проблема. Объекты-то нужно создавать в зависимости от значения закодированного типа. То есть нужно знать спецификацию, я имею ввиду знать, когда создать SomeType1, а когда SomeType2. А если спецификация должна быть задана динамически? То есть определит ее не наш код, а клиентский.

*Маша.* Отсюда естественный выход – инкапсулировать знание о выборе конкретной спецификации в отдельном методе (конструктор такое сделать не позволит, т.к. отвечает за создание конкретного объекта) и позволить пользователю переопределить его при необходимости.

*Даша.* А помните, Пол говорил нам про принцип принцип проектирования: инкапсулируйте то, что меняется.

*Петя.* Видимо изменение - это единственное постоянное в разработке программного обеспечения.

*Маша.* И Фабричный метод предоставляет возможность изменять тип создаваемого продукта. Поскольку все возвращаемые объекты имеет общий интерфейс SomeType, то для того, чтобы чтобы изменить тип создаваемого продукта, ты можешь просто переопределить Фабричный метод в подклассе:
```c#
public interface SomeType
{

}
public class SomeType3 : SomeType
{
}
abstract class SomeTypeCreator
{
    public method DoSomeVeryImportantOtherThanProductCreationStaff()
    {
        ....
    }
    protected abstract SomeType CreateSomeType();
}
public class SomeType3Creator : SomeTypeCreator
{
    public override SomeType CreateSomeType()
    {
        return new SomeType3();
    }
}
```
Клиентский код решает, какая спецификация нужна
```c#
SomeTypeCreator creator = new SomeType3Creator();
```
и вызывает метод
```c#
creator.CreateSomeType();
```
который SomeType3Creator переопределил по-своему.

*Саша.* Действительно, гибкое решение. Может еще какие фичи паттерн припрятал?

*Маша.* А то. Избавляемся от ограничений, присущих конструктору (например, null из конструктора не вернешь, а ведь бывает необходимость), а также метод есть метод, он может создавать объект отличным от обычного способом. Например, можно клонировать некоторый объект (Прототип), или возвращать единственный
экземпляр объекта (Синглтон).

*Саша.* Читал про Прототип. Несложно вроде. Это всего лишь клон.

*Петя.* Оно и видно, что читал. Уже спутал Бебеля с Гегелем.

*Маша.* Прототип - не то же самое, что клон.  Прототип использует клонирование, чтобы обойти лишнюю инициализацию. Ты создаешь Прототип, то есть объект, в котором инициализация уже проведена, и которая, как известно, может оказаться весьма дорогостоящей операцией. Но семантику клонирования ведь может использовать и не только Прототип. При помощи клонирования Прототип решает задачу создания нового объекта любого типа из сложной иерархии, когда тип создаваемого объекта определяется динамически.

*Саша.* Так а Фабричный метод разве не такую же задачу решает?

*Маша.* Верно, Прототип в некоторых случаях рассматривают как альтернативу.

*Саша.* И в каких таких случаях?

*Маша.* Допустим экземпляры твоего типа могут находиться в одном из не большого количества различных состояний. Тогда целесообразней создать соответствующее число прототипов для этих состояний и клонировать их, а не инстанцировать каждый раз тип вручную в подходящем состоянии.

*Саша.*  Выходит, метод клонирования переопределяется во всей иерархии. А так как клонирование производит сам объект, то получается Прототипу не требуется класс для создания объекта, а только сам объект.

*Маша.* Верно заметил. Ты избегаешь иерархии наследования создателей объекта.

*Саша.* Примерчик бы.

*Маша.* Проектировали мы как-то систему профессий для RPG игры. Давай предположим, что в игре нужна армия различных Эльфов.
Лучники, арбалетчики и т.д. Все профессии имеют одинаковое поведение по силе и здоровью, но отличаются видом оружия.

*Петя.* Давай. Если видов оружия не слишком много.

*Саша.* А если много?

*Маша.* То помимо конкретных классов Эльфов, придется прописывать по конкретному создателю (Creator)
на каждого Эльфа, включая Пикси.

*Петя.* Этот Пикси точно не последний Эльф в династии!

*Маша.* Если считаешь, что Пикси будет жирно иметь свою фабрику, есть и другой вариант. Каждый Пикси, как и любой другой подтип Эльфа, может размножаться самостоятельно.

*Петя.* Чувствую, нужно абстрагироваться от этого процесса и возложить ответственность на Эльфа.

*Маша.* Нужно использовать Прототип, а затем сконфигурировать тип оружия: (2)
```c#
public class Elf
{
    public int Power { get; } = 100;
    public int Health { get; } = 100;
    public Weapon Weapon { get; set; }

    public Elf Clone()
    {
         return (Elf) MemberwiseClone();
    }
}
```
*Маша.* Теперь можно конфигурировать армию Эльфов, упрощая ее создание:
```c#
Elf elf = new Elf(); // Прототип
Elf pixi = elf.Clone();
pixi.Weapon = WeaponforPixi;
Elf arbalester = elf.Clone();
arbalester.Weapon = WeaponforArbalester;
```
*Саша*. Ладно, технически я вижу, кто это реализовать. Но говорят, Барри на собеседовании может спросить про идеологичские различия. Так когда Прототип, а когда Фабрику? Или может Прототип вместо Фабрики?

*Маша.* Прототип лучше всего рассматривать как способ оптимизации Фабрики, но в тех случаях, когда необходимый объект аналогичен уже существующему или когда создание с нуля дороже клонирования (например, Power Эльфа - не примитив, а сложный тип).

*Витя.* Чисто фабричный пример для идеологии. У жены недавно появился метод ХочуЛаковыеТуфли(). Пошли в ИнтертопЛаковыхТуфель.

*Петя.* Фабричный метод в действии. Спецификация налицо. Так сказать конкретный Creator. С переопределенными методом, возвращающим именно лаковые туфли.

*Витя.* Потом оказалось, что такие туфли требуется носить исключительно с лаковой сумочкой. Пошли ИнтертопЛаковыхТуфельиСумочек.

*Петя.* Плавно переходим к Абстрактной фабрике. Так сказать к семейству взаимосвязанных продуктов.

*Витя.* Ключевое слово взаимосвязанных. Потому что жена сообщила, что вряд ли сумка от Авоськина подойдет
под туфли от Башмакова (на ее взгляд, это будет смотреться неэстетично). И мы пошли в СочетаемыхЛаковыхТуфлинЭндСумкин.

*Даша.* Требуется группировка индивидуальных, но связанных фабрик (лаковыхТуфлин и лаковыхСумкин), без указания их конкретных классов.

*Петя.* Полагаю, здесь вам трижды повезло. Во-первых, уже есть нужный вам комплект: совместимость туфель и сумочки обеспечивает сам производитель Сочетаемых. Во-вторых, он отвечает за создание как туфель, так и сумки (семейство взаимосвязанных продуктов). В-третьих, наконец-то метод вернул объекты.

*Саша.* Какая-то фабрика фабрик получается. Разве можно провести четкую границу?

*Маша.* Так оно и есть. Фабрика фабрик. Абстрактная фабрика внутри использует фабричный метод:
```c#
abstract class ShoesAndBagsCreator
{
    protected abstract Shoes CreateShoes(); // фабричный метод
    protected abstract Bag CreateBag(); // фабричный метод
}
public class LakyShoesAndBagsCreator : ShoesAndBagsCreator
{
    public override Shoes CreateShoes()
    {
        return new LakyShoes();
    }
    public override Bag CreateBag()
    {
        return new LakyBag();
    }
}
```
*Саша.* То есть отличий нет, ну, кроме количества фабричных методов?

*Маша.* Отличие в том, что Фабричный метод является методом,  а Абстрактная фабрика - объектом. Абстрактная фабрика использует агрегацию, то есть  делегирует ответственность по созданию объекта другому классу, тогда как Фабричный метод использует наследование и полагается на наследника.

*Даша.* А помните, Пол говорил, что Фабричные метод известен как Virtual Constructor (переопределение метода создания объекта). А Абстрактная фабрика известна как Kit (набор взаимосвязанных продуктов).

*Маша.* Клиентский код Абстрактной фабрики:
```c#
public class Client
{
    private ShoesAndBagsCreator creator;

    // делегируй задачу другому ShoesAndBagsCreator и получишь другие объекты
    public Client(ShoesAndBagsCreator shoesAndBagsCreator)
    {

        creator = shoesAndBagsCreator;
    }

    public void doSomething()
    {
        Shoes shoes = creator.CreateShoes();
        bag bag = creator.CreateBag();
    }
}
```
*Даша.* Я бы сказала, что Абстрактная фабрика на одном уровне абстракции выше, чем Фабричный метод. Фабричный метод абстрагирует способ создания объектов, а Абстрактная фабрика абстрагирует еще и способ создания фабрик, который, в свою очередь, абстрагирует способ создания объектов.

*Саша.* Технически постараюсь запомнить, чтобы было что сказать Барри. А идеологически...

*Петя.* А идеологически, если у тебя нету семейства туфли + сумка, значит не может быть и Абстрактной фабрики.

*Даша.* Можешь еще добавить, что клиенту Абстрактная фабрика гарантирует сочетаемость создаваемых продуктов, а программисту усложняет код из-за множества классов.

*Петя.* И еще можешь добавить, что если технически в Абстрактную фабрику нужно будет добавить новый продукт, придется менять интерфейс. А при изменении интерфейса придется каждый подкласс менять.

*Маша.* И передать привет принципам SOLID.

*Саша.* Почти готов собеседоваться. Как рассмотрим технику и идеологию Строителя, точно буду готов. Так  кто кого там абстрагирует?

*Маша.* Точнее инкапсулирует. Строитель инкапсулирует этапы создания объекта. Ведь в Фабрике создание объекта занимает один шаг, а за Строителем стоит множество шагов создания объекта:
```c#
public interface IBuilder
    Result { get; }
    void Step1();
    void Step2();
    void Step3();
```

*Саша.* Значит, когда есть много этапов создания объекта, выхода нет, кроме как использовать Строитель.

*Маша.* Выход есть. Конструктор с десятком параметров в качестве параметров создания объекта. Как тебе
такой вариант?

*Саша.* Полагаю, Строитель предпочтительней. А ведь он похож на Фабрику, только вместо того, чтобы сразу
вернуть созданный объект, он отвечает за этапы построения объекта. А порядок вызова этапов создания объекта также важен, как порядок параметров конструктора?

*Петя.* Когда как. Часто бывает, что способы создания объекта отличаются порядком и/или наличием этапов
его создания. В таком случае можно инкапсулировать способ создания объекта, т. е. вынести в отдельный класс Распорядителя или Директора, который заведует порядком этапов создания объекта:
```c#
public class Director
    IBuilder builder;

    public Result CreateSomething()
    {
        builder.step1();
        builder.step3();
        builder.step2();
        return builder.Result;
    }
```
Но бывает, что методы строителя могут напрямую вызываться клиентским кодом.

*Саша.* А если интерфейс Строителя содержит этапы создания объекта, но не содержит результат создания?

*Маша.* То клиентский код будет привязан к конкретному классу Строителя.

*Саша.* Технически разобрались. Идеологически могу сделать вывод, что клиент изолирован от кода пошаговой сборки продукта, а программист может использовать один и тот же код для создания различных продуктов.

*Петя.* Полагаю теперь, когда ты понимаешь, что такое Порождающие шаблоны, они стали для тебя *просто* Порождающими шаблонами.

> Все герои вымышлены, полное или частичное сходство является совпадением.
