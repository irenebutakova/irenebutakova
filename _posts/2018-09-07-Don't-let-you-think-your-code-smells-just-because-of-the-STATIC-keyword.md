---
published: true
layout: post
title: Don't let you think your code smells just because of the keyword STATIC.
date: 2018-09-07
---

Навеяно дискуссиями в группе...

*Саша.* Народ, мое приложение требует статический класс, а я не хочу делать класс статическим. Как же быть?

*Паша.* Хочешь - делай, не хочешь - переделай. Сам же приложение и проектировал. Вообще **static** - это зло.

*Маша.* **static** - это скорее зло, чем не зло. Но существуют вполне уместные случаи.

*Саша.* Так в результате моих уместных случаев страдает архитектура приложения.

*Паша.* Наверняка вместе с возможностью нормально протестировать код.

*Даша.* А помните, Пол говорил, что применяя статические члены класса мы ограничиваем наш проект возможностью построения гибкой архитектуры. Статические методы не могут быть полиморфными, а статические переменные и нормальная архитектура приложения — понятия несовместимые.

*Маша.* Речь шла об ограничениях, которые накладывает ключевое слово **static**, а также о глобальных данных.

*Петя.* Речь шла о Сode Smells.

*Маша.* Речь шла о Сode Smells в контексте неуместного использования **static**. Известно, что глобальные переменные - это зло, поскольку это состояние, которое может быть изменено кем угодно когда угодно. Однако многих проблем можно избежать, работая со статическими методами. Статические методы допускают чистый код. Код, который можно тестировать с меньшими издержками. Загляните в библиотеку классов .NET и увидите, что, в том числе там используются статические классы и методы, но не глобальные переменные.

*Саша.* Значит, статические методы не вызывают проблем?

*Маша.* Разве речь шла об этом? Статические методы могут вызывать проблемы, если они выполняют одно из следующих действий: либо изменяют статические данные - фактически это глобальные переменные, то есть Shared State, Code Smells и т.д., либо выполняют операции ввода-вывода, то есть неконтролируемые операции.

*Саша.* А как же мне написать чистый код для статического метода?

*Маша.* Убедиться в том, что статический метод не имеет доступа к каким-либо статическим данным, не вызывает IO-операции и зависит только от входных параметров, что означает, что при одинаковых входных данных метод всегда будет возвращать одинаковый результат.

*Саша.* А если возвращать нечего, void?

*Маша.* Для упрощения представь, что возвращаемое значение всегда есть.

*Саша.* Ну допустим статический метод чист и что-то возвращает. Но ведь я не смогу его использовать полиморфно.

*Маша.* А надо ли?

*Саша.* Ну мало ли...

*Маша.* Потому семь раз подумай, в каком случае уместно использовать статический метод.

*Саша.* Лучше уж ты один раз скажи.

*Маша.* Допустим, ты проектируешь класс. Обычно класс инкапсулирует состояние и поведение. Мы уже определили, что статические поля - это зло. Остаются статические методы, нестатические методы и
нестатические поля. Как известно, статический метод не может вызвать нестатические члены класса.
Получается, что статическая часть класса живет своей жизнью, выполняет свои задачи, и не пересекается с нестатической частью.

*Витя.* Ты клонишь к тому, что возможно нарушение принципа Single Responsibility?

*Маша.* Скорее всего.

*Саша.* Выход?

*Маша.* Как ни парадоксально звучит, - инкапсулировать статическую часть в отдельный класс и в целях повышения производительности сделать его статическим.

*Паша.* А тебе не кажется, что в ООП объекты без какого-либо внутреннего состояния является подозрительной вещью?

*Маша.* Об объектах речь не идет вовсе - статический класс, содержащий исключительно статические методы. По сути у тебя получается вспомогательный класс. Мини-утилита. Которую при желании и протестировать можно.

*Саша.* Выходит, статические методы замечательно подходят для служебных статических классов. И не прибавляют плохое архитектурное решение.

*Витя.* Не прибавляют в случае, если подобных классов не так уж много.

*Маша.* И прибавляют функциональный дизайн на языке объектов.

*Саша.* И возможно убавляют Code Smells.


> Все герои вымышлены, полное или частичное сходство является совпадением.
